---
title: JWT
author: lujae
date: 2023-09-27 00:34:00 +0800
categories: [Web]
tags: [JWT, Authentication]
layout: posts
toc: true
---

웹에서의 네트워크 구조는 client - server 구조이다. client가 요청을 보내고 해당 요청에 대한 응답을 server보내는 형식으로 데이터를 처리한다. clinent가 server로 요청을 보낼 때 client-server간 연결이 생기고 server의 응답을 client가 수신하면 연결이 끊기게 된다. 이런 이유로server는 요청을 받았을 때 해당 요청을 보낸 client가 이전에 어떤 요청을 보냈는지 구분할 수 없다. client의 이전 정보를 기억하지 않는 server의 이런 특성을 **stateless**라고 한다.

stateless는 server가 사용자를 구별하지 못함을 의미한다. 하지만 우리가 웹 페이지를 사용할 때를 생각해보면, server가 내가 어떤 사용자인지 식별하는 것처럼 느껴진다. 로그인을 하고 나의 장바구니를 보여 달라는 요청을 server로 보내면 server는 해당 사용자가 담았던 장바구니 목록을 응답으로 알려준다.

stateless server가 현재 요청을 보낸 client가 어떤 client인지 구별하기 위해 쿠키, 세션, 토큰같은 방법들이 고안 되었고 토큰을 통해 client를 식별하는 방식이 최신 방식이다. 그리고 토큰의 한 예시인 JWT에 대해 알아보려고 한다.

# 개념

JWT는 Json Web Token의 약자로, 인증에 필요한 정보들을 암호화 시킨 JSON 토큰이다. server가 자격을 증명해주는 내용을 암호화 하여 토큰에 저장하고 해당 토큰을 클라이언트에게 전달하면 JWT 토큰 발급의 과정이 완료된다. 자격 증명에 대한 내용이 담긴 토큰을 받은 클라이언트는 자격이 필요한 요청마다 토큰을 첨가하여 서버로 요청을 보낸다. 서버는 클라이언트의 요청을 분석하여 해당 자격이 있는지 검증하고 최종적으로 클라이언트를 식별할 수 있다.

# 구조

![jwt](./image/jwt/jwt_structure.png)

jwt는 헤더, 페이로드, 서명으로 구분되고 '.'로 연결된다. 서버가 발급하는 토큰은 실제 내용물 하고는 인코딩 차이가 있다. 각 요소의 실제 내용물에서 인코딩 과정을 거치면 토큰에서의 내용을 얻을 수 있고 토큰에서 디코딩 과정을 거치면 실제 내용물을 얻을 수 있다.

| 구분     | 내용                                                                                                       | 설명                                                                                                                                                                                                                                                            |
| -------- | ---------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 헤더     | {<br />    "alg": "HS256",<br />    "typ": "JWT"<br />}                                                    | • 서명 생성 알고리즘을 지정                                                                                                                                                                                                                                     |
| 페이로드 | {<br />    "loggedInAs" : "admin",<br />    "iat" : 1422779638<br />}                                      | • 클레임들을 포함<br />• iat: 표준 issued at time 클레임<br />• loggedInAs: 사용자지정 클레임                                                                                                                                                                   |
| 서명     | HMAC-SHA256(<br />    secret,<br />    base64urlEncoding(header) + '.' + base64urlEncoding(payload)<br />) | •서명 파트는 암호화 되어 있어서 client가 복호화 할 수 없음<br />• Base64Url 인코딩을 이용하여 헤더와 페이로드를 .로 구분하여 연결함<br />• 이후 만들어진 문자열은 헤더의 암호화 알고리즘(HMAC-SHA256)이 적용됨 <br />•secret은 서버가 가지고 있는 개인키를 의미 |

## 헤더 (header)

토큰의 타입과 어떤 암호화 알고리즘을 사용할 것인지 명시

## 페이로드 (payload)

key-value 쌍 형태로 entity에 대한 정보를 저장하며 각각의 쌍을 클레임이라고 한다. 표준 스펙에서는 공식적으로 7가지 클레임을 정의하고 있으며 개발 요구사항에 맞춰 사용자 지정 클레임을 추가할 수 있다. 하지만 페이로드는 암호화 되지 않는 부분이기 때문에 민감한 정보를 클레임으로 담고 있지 않도록 주의해야한다.

```
1. iss(Issuer) : 토큰 발급자
2. sub(Subjec) : 토큰 제목
3. aud(Audience) : 토큰 대상자
4. exp(Expiration Time) : 토큰 만료 시간
5. nbf(Not Before) : 토큰 활성 날짜
6. iat(Issued At) : 토큰 발급 시간
7. jti(JWT Id) : JWT 토큰 식별자 (issuer가 여러 명일 때 구분하기 위한 값)
```

## 서명(Signature)

base64urlendoding 방식으로 헤더와 페이로드를 변환하고 secret을 키로하여금 내용물을 해쉬로 변환한다. 그리고 해쉬 값을 인코딩 시키면 서버가 발급하는 토큰에서의 서명에 해당하는 문자열을 얻게된다.

# 동작 방식

Authentication(인증) 과정에서 사용자는 자신의 정보를 입력하고 서비스에 등록된 정보와 일치한다면 서비스의 서버로부터 JWT를 발급 받는다. 그리고 사용자가 사용하는 브라우저(Client)는 발급된 토큰을 저장하고 있다가, 외부로부터 보호되어야 하는 자원에 접근하기 위해 해당 토큰을 요청에 포함 시킨다.

브라우저는 HTTP를 따라 서버와 통신하며, Authorization header에 발급 받은 JWT 내용을 명시한다. 이때 특이한 점은 Bearer Schema를 사용한다. Bearer은 Authorization header에서 type을 설명하는 역할을 한다. 구체적으로는 JWT 혹은 OAuth에 대한 토큰을 사용한다는 의미이다.

추가적으로 Authorization header를 통해 토큰 값을 넘겨주는 경우 쿠키를 사용하지 않기 때문에, CORS는 문제가 되지 않는다고한다.

```
Authorization: Bearer <token>
```

하지만 위 같이 Authentication을 위한 토큰 발급을 단일 토큰으로 수행하게 된다면 보안상 위험이 있다. 서버로부터 인증 받은 토큰을 본래의 사용자가 아닌 제 3자가 탈취를 하게 되면, 제3자가 본래 사용자인마냥 여러 자원에 대한 권한을 남용할 수 있게 된다.

이런 문제를 완화하기 위해서 Access Token & Refresh Token를 사용한다. JWT는 생성후 삭제가 불가하기 때문에, 유효시간 개념으로 삭제를 대체한다. 토큰이 탈취되었을때, 유효시간이 길다는 것은 오랜 시간 동안 제 3자가 악용을 할 수 있다는 의미이다. 이와 반대로, 유효 시간이 짧은 토큰은 제3자가 악용할 기회가 적다. 이런 생각으로부터, 보호된 자원에 접근 권한을 증명하는 Access Token의 유효 시간을 짧게 한다. 하지만 이렇게 된다면 사용자는 자신의 Access Token을 발급 받도록 로그인을 더 자주 해야한다. 이런 불편함을 해소하기 위해 Refresh Token이란 개념이 등장한다. Refresh Token은 자원에 대한 접근에서는 영향력이 없지만, Access Token의 재발급이 필요할 때 이를 허가해주는 열쇠가 된다.

사용자가 최초 인증 시 server는 Access Token 과 Refresh Token을 생성하고 이를 client에게 전달한다. 그리고 Refresh Token은 서버 내부 DB에 저장하였다가 client가 Refresh Token을 포함시켜 요청을 보내면 저장된 Refresh Token을 활용하여 Access Token의 새로운 발급 여부 결정한다.

사용자의 Access Token이 만료된 경우를 살펴보자.

1. 사용자는 AccessToken이 만료된지도 AccessToken을 담아 서버로 요청을 보낸다.
2. 서버는 토큰이 유효한지 검사를 하고 만료된 토큰임을 확인하여 권한이 없다고 클라이언트에게 알린다.
3. 권한이 없다고 수신받은 클라이언트는 Access Token과 Refresh Token을 동시에 담아 요청을 보낸다.
4. 서버는 클라이언트가 보낸 Refresh Token과 내부 DB에서 저장하고 있던 Refresh Token을 비교하여 Refresh Token이 동일하고 유효기간도 지나지 않았다면 새로운 Access Token을 발급한다.

# 출처

https://ko.wikipedia.org/wiki/JSON_%EC%9B%B9_%ED%86%A0%ED%81%B0

https://ksh-coding.tistory.com/58
